/// <reference lib="webworker" />
declare const self: ServiceWorkerGlobalScope;

// Extend ServiceWorkerGlobalScopeEventMap to include sync events
declare global {
  interface ServiceWorkerGlobalScopeEventMap {
    sync: SyncEvent;
  }
  
  interface SyncEvent extends ExtendableEvent {
    readonly tag: string;
    readonly lastChance: boolean;
  }
}

// Service worker implementation for the CGPA Calculator PWA
import { precacheAndRoute } from 'workbox-precaching'
import { registerRoute } from 'workbox-routing'
import { StaleWhileRevalidate, CacheFirst } from 'workbox-strategies'
import { ExpirationPlugin } from 'workbox-expiration'
import { CacheableResponsePlugin } from 'workbox-cacheable-response'

// Precache all assets generated by the build process
precacheAndRoute(self.__WB_MANIFEST)

// Cache Google Fonts stylesheets with a StaleWhileRevalidate strategy
registerRoute(
  /^https:\/\/fonts\.googleapis\.com/,
  new StaleWhileRevalidate({
    cacheName: 'google-fonts-stylesheets',
  })
)

// Cache Google Fonts webfont files with a CacheFirst strategy
registerRoute(
  /^https:\/\/fonts\.gstatic\.com/,
  new CacheFirst({
    cacheName: 'google-fonts-webfonts',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
        maxEntries: 30,
      }),
    ],
  })
)

// Cache images with a CacheFirst strategy
registerRoute(
  /\.(?:png|jpg|jpeg|svg|gif|webp)$/,
  new CacheFirst({
    cacheName: 'images',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 Days
      }),
    ],
  })
)

// Cache CSS and JavaScript files with a StaleWhileRevalidate strategy
registerRoute(
  /\.(?:js|css)$/,
  new StaleWhileRevalidate({
    cacheName: 'static-resources',
  })
)

// Background sync for pending operations
self.addEventListener('sync', (event: SyncEvent) => {
  if (event.tag === 'sync-pending-data') {
    event.waitUntil(syncPendingData())
  }
})

// Function to sync pending data when back online
async function syncPendingData() {
  // In a real implementation, this would sync data with a server
  // For this example, we'll just post a message to the client
  const clients = await self.clients.matchAll()
  clients.forEach(client => {
    client.postMessage({
      type: 'SYNC_COMPLETED',
      timestamp: new Date().getTime()
    })
  })
}

// Skip waiting to ensure new service worker activates immediately
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting()
  }
})